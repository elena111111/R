# R
## knn - метод k ближайших соседей.
ƒана выборка ирисов ‘ишера(150 элементов), в ней 3 класса(setosa, versicolor, virginica). 
ћы хотим классифицировать множество точек *{z}* по 2м признакам (Petal.Length, Petal.Width). Ёти же признаки - координаты точек на графике.
ћассив *xl* хранит координаты точек исходной выборки и название класса, к которому относитс€ соответствующа€ точка.

ƒл€ каждой точки *z* построим вспомогательный вектор *distances*, в котором будем хранить рассто€ни€ от точки *z* до каждой точки из выборки.
ћассив *orderedxl* - это массив *xl*, отсортированный так, чтобы точки шли в пор€дке увеличени€ рассто€ни€ от *z* до точки из выборки.
“еперь заберЄм из *orderedxl* только первые *k* строк (получим *k* ближайших соседей) и в этих строках оставим только столбец названий классов (массив *classes*).
“очка *z* относитс€ к тому классу, который чаще всего встречаетс€ в *classes*.

ќптимальное *k* подбираетс€ по *LOO* (скольз€щий контроль), который работает следующим образом: 
ѕусть переменна€ *Q = 0*.
»з выборки(*X*) будем исключать по одной точке (пусть будет точка *zi*) - получим выборку *X2*. 
“еперь запустим алгоритм(*knn*), как будто мы хотим классифицировать точку *zi*, и имеем выборку *X2*.
≈сли алгоритм ошибс€, то к величине *Q* прибавим 1.
 огда мы таким образом переберЄм все точки выборки, вычислим *Loo = Q/l*, где *l* - количество точек в выборке *X*.

Ѕудем делать это дл€ разных *k* от 1 до *l*.
ќптимальным будет *k*, при котором величина *Loo* минимальна.

–езультат работы программы: 
![alt text](https://github.com/elena111111/R/blob/master/knn/knn.png)

«ависимость *Loo* от *k*:
![alt text](https://github.com/elena111111/R/blob/master/knn/knn_loo.png)