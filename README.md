# R


## knn - метод k ближайших соседей.
Дана выборка ирисов Фишера(150 элементов), в ней 3 класса(*setosa*, *versicolor*, *virginica*). 
Мы хотим классифицировать множество точек *{z}* по 2м признакам (Petal.Length, Petal.Width). Эти же признаки - координаты точек на графике.
Массив *xl* хранит координаты точек исходной выборки и название класса, к которому относится соответствующая точка.

Для каждой точки *z* построим вспомогательный вектор *distances*, в котором будем хранить расстояния от точки *z* до каждой точки из выборки.
Массив *orderedxl* - это массив *xl*, отсортированный так, чтобы точки шли в порядке увеличения расстояния от *z* до точки из выборки.
Теперь заберём из *orderedxl* только первые *k* строк (получим *k* ближайших соседей) и в этих строках оставим только столбец названий классов (массив *classes*).
Точка *z* относится к тому классу, который чаще всего встречается в *classes*.

Оптимальное *k* подбирается по *LOO* (скользящий контроль), который работает следующим образом: 
Пусть переменная *Q = 0*.
Из выборки(*X*) будем исключать по одной точке (пусть будет точка *zi*) - получим выборку *X2*. 
Теперь запустим алгоритм(*knn*), как будто мы хотим классифицировать точку *zi*, и имеем выборку *X2*.
Если алгоритм ошибся, то к величине *Q* прибавим 1.
Когда мы таким образом переберём все точки выборки, вычислим *Loo = Q/l*, где *l* - количество точек в выборке *X*.

Будем делать это для разных *k* от 1 до *l*.
Оптимальным будет *k*, при котором величина *Loo* минимальна.

Результат работы программы: 

![alt text](https://github.com/elena111111/R/blob/master/knn/knn.png)

Зависимость *Loo* от *k*:

![alt text](https://github.com/elena111111/R/blob/master/knn/knn_loo.png)


# Алгортим k взвешенных ближайших соседей (wknn).
Имеется выборка *X* (ирисы Фишера), и 3 класса (*setosa*, *versicolor*, *virginica*). 
Мы хотим классифицировать множество точек *{z}*.
Классификацию проводим по двум признакам (Petal.Length, Petal.Width), они же являются координатами точек.
*distances* - это вектор расстояний от точки *z* до каждой точки из выборки *X*.
*orderedxl* - это массив *xl*, отсортированный по возрастанию расстояний от точки *z* до каждой точки из выборки *X*.
Мы выбрали весовую функцию *q^i*.
Для *k* ближайших соседей построим соответствующие веса.
В массиве *classes* будет *k* строк, а в столбцах название класса и вес точки. 
Осталось найти сумму весов для каждого класса отдельно в *classes* (это массив *ans*).
Ответом будет тот класс, вес которого максимален в *ans*.

Значение *q* подбирается по *LOO*, который работает следующим образом:
Пусть переменная *Q = 0*.
Из выборки(*X*) будем исключать по одной точке (пусть будет точка *zi*) - получим выборку *X2*. 
Теперь запустим алгоритм(*wknn*), как будто мы хотим классифицировать точку *zi*, и имеем выборку *X2*.
Если алгоритм ошибся, то к величине *Q* прибавим 1.
Когда мы таким образом переберём все точки выборки, вычислим *Loo = Q/l*, где *l* - количество точек в выборке *X*.

Будем делать это для разных *q*, которые могут находиться в интервале *(0; 1)*.
Оптимальным будет *q*, при котором величина *Loo* минимальна.

Результат работы программы: 

![alt text](https://github.com/elena111111/R/blob/master/wknn/wknn.png)

Зависимость *Loo* от *q*:

![alt text](https://github.com/elena111111/R/blob/master/wknn/wknn_loo_q.png)

